﻿#注意！！！##我之前没注意到是用markdown编写，直接用word了，所以导致排版异常混乱，但是我打印了纸质版的带去面试。请各位dalao谅解！！基础题char *s = “aaa”;  /*定义s为指向字符串的首字符的指针变量*/char s[] = “aaa”;  /*定义s为长度为4的字符数组*/2.	所谓对象就是由一组数据结构和处理它们的方法组成的，划重点 “数据” 包括对象的特性、状态等的静态信息； “方法” 也就是行为，包括该对象的对数据的操作、功能等能动信息。把相同行为的对象归纳为类，类是一个抽象的概念，对象是类的具体。简单点说：对象就是类的实例。例如：一个水果店，就是一个类，它是所有水果的集合。里面的具体水果就是对象。   清楚了什么是对象之后，接下来就是理解什么是面向对象。   面向对象的目的：解决软件系统的可扩展性，可维护性和可重用性；   面向对象的三大特性：封装、多态和继承   封装（对应可扩展性）：隐藏对象的属性和实现细节，仅对外公开接口,控制在程序中属性的读和修改的访问级别。封装是通过访问控制符（public protected private）来实现。一个类就可看成一个封装。   多态（可维护性和可扩展性）：接口的不同实现方式即为多态。接口是对行为的抽象，刚才在封装提到，找到变化部分并封装起来，但是封装起来后，怎么适应接下来的变化？这正是接口的作用，接口的主要目的是为不相关的类提供通用的处理服务,我们可以想象一下。比如鸟会飞，但是超人也会飞，通过飞这个接口，我们可以让鸟和超人，都实现这个接口。   继承（重用性和扩展性）：子类继承父类，可以继承父类的方法和属性。可以对父类方向进行覆盖（实现了多态）。但是继承破坏了封装，因为他是对子类开放的，修改父类会导致所有子类的改变，因此继承一定程度上又破坏了系统的可扩展性，所以继承需要慎用，只有明确的IS-A关系才能使用。所以继承要慎用，尽量优先使用组合。   面向对象编程（OOP）其实就是一种设计思想，在程序设计过程中把每一部分都尽量当成一个对象来考虑，以实现软件系统的可扩展性，可维护性和可重用性。3. TCP握手协议 在TCP/IP协议中,TCP协议提供可靠的连接服务,采用三次握手建立一个连接.第一次握手：建立连接时,客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认； SYN：同步序列编号(Synchronize Sequence Numbers)第二次握手：服务器收到syn包,必须确认客户的SYN（ack=j+1）,同时自己也发送一个SYN包（syn=k）,即SYN+ACK包,此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手.完成三次握手,客户端与服务器开始传送数据.TCP四次挥手机制： 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 （1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送； （2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1，和SYN一样，一个FIN将占用一个序号； （3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A； （4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1 4.OSI采用了分层的结构化技术，共分七层，物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。物理层：负责0,1比特流和电压高低、光的闪灭之间的转换 数据链层：互联设备之间传送和识别数据帧 网络层：负责地址管理和路由选择 传输层：管理两节点的数据传输，确保数据被可靠地传送到目标地址 会话层：负责建立和断开连接通信 表示层：将设备固有的数据格式转换为网络标准的传输格式 应用层：提供各种应用协议。如：文件传输、电子邮件等协议。TCP/IP是一组用于实现网络互连的通信协议。Internet网络体系结构以TCP/IP为核心。基于TCP/IP的参考模型将协议分成四个层次，它们分别是：网络访问层、网际互联层、传输层（主机到主机）、和应用层。1. 应用层应用层对应于OSI参考模型的高层，为用户提供所需要的各种服务，例如：FTP、Telnet、DNS、SMTP等.2. 传输层传输层对应于OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。该层定义了两个主要的协议：传输控制协议（TCP）和用户数据报协议（UDP).TCP协议提供的是一种可靠的、通过“三次握手”来连接的数据传输服务；而UDP协议提供的则是不保证可靠的（并不是不可靠）、无连接的数据传输服务.3. 网际互联层网际互联层对应于OSI参考模型的网络层，主要解决主机到主机的通信问题。它所包含的协议设计数据包在整个网络上的逻辑传输。注重重新赋予主机一个IP地址来完成对主机的寻址，它还负责数据包在多种网络中的路由。该层有三个主要协议：网际协议（IP）、互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。IP协议是网际互联层最重要的协议，它提供的是一个可靠、无连接的数据报传递服务。4. 网络接入层（即主机-网络层）网络接入层与OSI参考模型中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。地址解析协议（ARP）工作在此层，即OSI参考模型的数据链路层。5. 13Bit（4+1+2+6）6.int main() {   Int x,a,b = 17;   x = scanf(“%d”,a);   printf(“%d,%d,%d,%d\n”,2017,a,x,printf(“%d\n”,b));   return 0; } 该代码有问题，a没有赋值，所以a无法输出，a前没有&，无法给x赋值，所以x也无法输出7. *(&a[0][0]+5);  *(*(a+1)+1); 和 *(a[1]+1); 可以表示a[1][1]8.输出结果为 2,49.(1).选择排序#include<stdio.h>  void SelectionSort(int *num,int n)  {   int i = 0;   int min = 0;   int j = 0;   int tmp = 0;   for(i = 0;i < n-1;i++)   {      min = i;      for(j = i;j < n;j++)       {        if(num[min]>num[j])        {         min = j;        }      }      if(min != i)       {        tmp = num[min];        num[min] = num[i];        num[i] = tmp;      }   }  }    int main()  {   int num[6] = {5,4,3,2,9,1};   int i = 0;   SelectionSort(num,6); for(i = 0;i < 6;i++)   {     printf("%d ",num[i]);   }   return 0;  }   (2).冒泡排序#include<stdio.h>  void main()  {      int i,j,a[10];      for(i=0;i<10;i++)          scanf("%d",&a[i]);        for(i=0;i<10-1;i++)            {         for(j=i+1;j<10;j++)                     if(a[j-1]>a[j])                        {                  int t=a[j];                  a[j]=a[j+1];                  a[j+1]=t;              }      }        for(i=0;i<10;i++)                       printf(" %d",a[i]);  }   (3).插入排序#include<stdio.h>void insert_sort(int a[],int n){    int i,j;    int temp;    for ( i=1; i<n; i++)   {      temp=a[i];       j=i-1;      while ((j>=0)&& (temp<a[j])){          a[j+1]=a[j];          j--;          }      a[j+1]=temp;   }}void main(){    int array[]={2, 10, 4, 5, 1, 9};    int i=0;    insert_sort(array,6);    for(;i<=5;i++)       printf("[%d]",array[i]);    getch();} (4).归并排序#include<stdio.h>void mergeArray(int a[], int first, int mid, int last){     int i, j, m, n;       i = first, m = mid;       j = mid+1, n = last;     int k = 0;     int temp[SIZE]; while(i<=m && j<=n) {         if(a[i] < a[j]) {             temp[k++] = a[i++];         } else {             temp[k++] = a[j++];         }     }         while(i<=m) temp[k++] = a[i++];      while(j<=n) temp[k++] = a[j++];        for(i=0; i<k; i++) {          a[first+i] = temp[i];     }  }void merge_sort(int a[], int start, int end) {    int mid = (start+end)/2;       if(start<end) {         merge_sort(a, start, mid);         merge_sort(a, mid+1, end);         mergeArray(a, start, mid, end);     } } (5).快速排序#include "stdafx.h"  #include <stdio.h>    void quick_sort(int s[], int l, int r)  {      int i, j, x;      if (l < r)      {          i = l;          j = r;          x = s[i];          while (i < j)          {              while(i < j && s[j] > x)                   j--;             if(i < j)                   s[i++] = s[j];                while(i < j && s[i] < x)                   i++;             if(i < j)                   s[j--] = s[i];            }          s[i] = x;          quick_sort(s, l, i-1); /* 递归调用 */          quick_sort(s, i+1, r);      }  }      int _tmain(int argc, _TCHAR* argv[])  {            int a[]={49,38,65,97,76,13,27};      int l = 0;      int r = 6;      quick_sort(a,l,r);        for(int i=0;i<=r;i++)          printf("%4d",a[i]);      return 0;  }  此外还有希尔排序，基数排序，堆排序等并不常见，在这里亦不列举10.#include <stdio.h>#include <string.h>char A(char ch[20], char sh[20]){	int i, j, c, d;	char wh[40];	c = strlen(ch);	d = strlen(sh);	for (i = 0; i < c; i++)	{		wh[i] = ch[i];	}	for (j = i; j < c + d; j++)	{		wh[j] = sh[j - c];	}	for (i = 0; i < c + d; i++)	{		printf("%c", wh[i]);	}}main(){	char a[20] = "abcdefg";	char b[20] = "1234567";	A(a, b);}前端题1.HTML5,超文本标记语言，是一种基于标签的描述性的标记语言。我理解为搭房子。CSS3, 层叠样式表，是一种描述性语言。我理解为贴墙纸。ECMAScript6, 种多范式动态强类型脚本语言，有强大的引擎V8和chakra撑腰，由ECMA组织定义语言标准，标准名称为ECMA262。我理解为装修规划。2.cookies数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，cookie只适合保存很小的数据，如会话标识。cookies在所有同源窗口中都是共享的。localStorage 不会自动把数据发给服务器，仅在本地保存。存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。localStorage在所有同源窗口中都是共享的。sessionStorage 方法针对一个 session 进行数据存储。当用户关闭网页后，数据会被删除。sessionStorage不在不同的浏览器窗口中共享。3.前端模块化的前身是胖客户端，它是根据实际应用，需要多少写多少，不便于它的维护和系统的升级。组件化开发源于后台开发的JAVA/C++的一种思维理念，主要源于封装，继承，多态。把每一个东西都作为一个独立的模块，可以复用。同时也可以调用，大大减少了代码后期的修改和升级的难度。Fetch 将一种新的 Ajax 的网络请求APIAjax利用的是XMLHttpRequest对象来请求数据的。Fetch 是浏览器提供的原生 AJAX 接口。使用 window.fetch 函数可以代替以前的 $.ajax、$.get 和 $.post。5.	冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。事件捕获阶段：事件从最上一级标签开始往下查找，直到捕获到事件目标(target)。事件冒泡阶段：事件从事件目标(target)开始，往上冒泡直到页面的最上一级标签。6.(1) 1,2,1  运行了5次Fun3,输出one,根据性能不同输出one，two。一共5个one，5个two (2)blue   Red7. var array = new Array(100);array = array.join("1").split("");console.log(array);8. // Array.prototype.sort() var fruit = ['apples', 'bananas', 'Cherries'];fruit.sort(); // ['Cherries', 'apples', 'bananas']; var scores = [1, 2, 10, 21]; scores.sort(); // [1, 10, 2, 21] var things = ['word', 'Word', '1 Word', '2 Words'];things.sort(); // ['1 Word', '2 Words', 'Word', 'word']9.10.